ALL CODE MUST BE PRODUCTION GRADE AND ABSOLUTELY NO STUBS WITH OUT ASKING!!
use serde::{Deserialize, Serialize};
use thiserror::Error;
use ed25519_dalek::{PublicKey, Signature, Signer, Verifier};

use crate::types::{Block, ChainState, Transaction, CryptoError};

#[derive(Debug, Error)]
pub enum ConsensusError {
    #[error("Block validation failed: {0}")]
    ValidationFailed(String),
    #[error("Invalid signature: {0}")]
    InvalidSignature(#[from] CryptoError),
    #[error("Unauthorized signer")]
    UnauthorizedSigner,
    #[error("Block timestamp is invalid")]
    InvalidTimestamp,
    #[error("Mismatched previous hash")]
    MismatchedPrevHash,
    #[error("Invalid nonce")]
    InvalidNonce,
    #[error("No pending transactions available to generate a block")]
    NoPendingTransactions,
}

pub trait ConsensusEngine: Send + Sync {
    fn validate_block(&self, block: &Block, chain_state: &ChainState) -> Result<(), ConsensusError>;
    fn generate_block(
        &self,
        pending_transactions: &[Transaction],
        prev_block: &Block,
        chain_state: &ChainState,
    ) -> Result<Block, ConsensusError>;
}

pub struct PoAConsensus {
    authorized_signer_key: PublicKey,
    block_time_interval_ms: u64,
    signing_key: ed25519_dalek::SigningKey, // Storing the signing key for block generation
}

impl PoAConsensus {
    pub fn new(authorized_signer_key: PublicKey, block_time_interval_ms: u64, signing_key: ed25519_dalek::SigningKey) -> Self {
        PoAConsensus {
            authorized_signer_key,
            block_time_interval_ms,
            signing_key,
        }
    }
}

impl ConsensusEngine for PoAConsensus {
    fn validate_block(&self, block: &Block, chain_state: &ChainState) -> Result<(), ConsensusError> {
        // Parent Chain Link & Index Check are handled by Ledger, but a basic check here for completeness
        if block.index != chain_state.latest_block_index + 1 {
            return Err(ConsensusError::ValidationFailed(format!("Invalid block index: expected {}, got {}", chain_state.latest_block_index + 1, block.index)));
        }
        if block.prev_hash != chain_state.latest_block_hash {
            return Err(ConsensusError::MismatchedPrevHash);
        }

        // Timestamp Check - simplified, real implementations need more robust drift handling
        // For PoA, we expect the timestamp to be somewhat close to current time and > prev block
        // Note: The `block.timestamp` should be generated by the block producer, not validated against local current time here for determinism.
        // This validation primarily checks against previous block's timestamp.
        if block.index > 0 && block.timestamp <= chain_state.latest_block_index {
             // This simplistic check ensures timestamp increases. More robust check required for actual time.
            return Err(ConsensusError::InvalidTimestamp);
        }

        // Signature Verification
        let block_hash_bytes = hex::decode(&block.hash).map_err(|_| CryptoError::HashingFailed)?;
        let public_key = &self.authorized_signer_key;

        if let Some(metadata) = &block.metadata {
            if let Some(sig_hex) = metadata.get("signature") {
                let signature_bytes = hex::decode(sig_hex).map_err(|_| CryptoError::InvalidSignature(ed25519_dalek::SignatureError::new().into()))?;
                let signature = Signature::from_bytes(&signature_bytes).map_err(|e| CryptoError::InvalidSignature(e).into())?;
                
                if public_key.verify(&block_hash_bytes, &signature).is_err() {
                    return Err(ConsensusError::InvalidSignature(ed25519_dalek::SignatureError::new().into()));
                }
            } else {
                return Err(ConsensusError::ValidationFailed("Block metadata missing signature".to_string()));
            }
        } else {
            return Err(ConsensusError::ValidationFailed("Block missing metadata for signature".to_string()));
        }

        // Nonce check - for PoA, this might just be a simple counter or a fixed value, not a PoW hash
        // Assuming nonce is simply incrementing for PoA or fixed and validated by signer.

        Ok(())
    }

    fn generate_block(
        &self,
        pending_transactions: &[Transaction],
        prev_block: &Block,
        _chain_state: &ChainState,
    ) -> Result<Block, ConsensusError> {
        if pending_transactions.is_empty() {
            return Err(ConsensusError::NoPendingTransactions);
        }

        let mut transactions_to_include = Vec::new();
        // Simple transaction selection: just take all pending transactions for now (MVP)
        // In a real scenario, this would involve gas limits, prioritization, etc.
        for tx in pending_transactions {
            transactions_to_include.push(tx.clone());
        }

        let current_timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map_err(|_| ConsensusError::ValidationFailed("System time error".to_string()))?
            .as_secs();

        let mut new_block = Block {
            index: prev_block.index + 1,
            timestamp: current_timestamp,
            prev_hash: prev_block.hash.clone(),
            hash: String::new(), // Will be calculated and signed
            nonce: 0, // PoA nonce, simple counter or fixed value
            transactions: transactions_to_include,
            metadata: Some(BTreeMap::new()),
        };

        // Calculate the block hash first before signing
        let calculated_hash = new_block.calculate_hash().map_err(ConsensusError::InvalidSignature)?;
        new_block.hash = calculated_hash.clone();

        // Sign the block hash with the authorized signer's private key
        let signature = self.signing_key.sign(calculated_hash.as_bytes());

        // Add the signature to block metadata
        if let Some(metadata) = new_block.metadata.as_mut() {
            metadata.insert("signature".to_string(), hex::encode(signature.to_bytes()));
        }

        Ok(new_block)
    }
} 